# node = hou.pwd()

#custom undo stack 
with hou.undos.group("Poly Reduce Groups"):
    #uses parent, otherwise recursion happens with python sop node
    node = node.inputs()[0]
    geo = node.geometry()
    groups = geo.primGroups()
    count = 0
    mainReduce = ''
    
    merge = node.parent().createNode('merge')
    
    for o in groups:
    
        #keep a single prim group
        blast = node.parent().createNode('blast')
        blast.setInput(0,node)
        blast.moveToGoodPosition()
        blast.parm('negate').set(True)
        blast.parm('group').set(o.name())
        
        #use polyreduce with keep points on with an expression
        reduce = node.parent().createNode('polyreduce')
        reduce.setInput(0,blast)
        reduce.moveToGoodPosition()
    
        reduce.parm('originalpoints').set(True)
        reduce.parm('referframe').set(True)
        reduce.parm('framereference').setExpression('round((\$F+'+str(count)+')/ch("step"))*ch("step")')
    
        #create the 'step by' channel on this node
        parmTemplateGrp = reduce.parmTemplateGroup()
        stepByParm = hou.FloatParmTemplate('step', 'StepBy', 1,default_value=([10]))
        parmTemplateGrp.append(stepByParm)
        reduce.setParmTemplateGroup(parmTemplateGrp)
    
        if count == 0:
            reduce.setColor(hou.Color([0.6,1,0.6]))
            mainReduce = reduce
            reduce.parm('percentage').set(10)
            
        else:
            params = ['percentage','optimizationbias','borderweight','attribweight','topologicalweight','step']
            for element in params:
                reduce.parm(element).set(mainReduce.parm(element))
    
        merge.setInput(count,reduce,0)
        count = count + 1
        
    merge.moveToGoodPosition()
    merge.setDisplayFlag(True)
    mainReduce.setSelected(True, clear_all_selected=True)
